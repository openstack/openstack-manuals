<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
         xml:id="section_networking-adv-features">
    <title>Advanced features through API extensions</title>
    <para>Several plug-ins implement API extensions that provide capabilities similar to what was
        available in nova-network: These plug-ins are likely to be of interest to the OpenStack
        community.</para>
    <section xml:id="section_provider_networks">
        <title>Provider networks</title>
        <para>Networks can be categorized as either "tenant networks" or "provider networks". Tenant
            networks are created by normal users and details about how they are physically realized
            are hidden from those users. Provider networks are created with administrative
            credentials, specifying the details of how the network is physically realized, usually
            to match some existing network in the data center.</para>
        <para>Provider networks enable cloud administrators to create Networking networks that map
            directly to the physical networks in the data center. This is commonly used to give
            tenants direct access to a public network that can be used to reach the Internet. It
            might also be used to integrate with VLANs in the network that already have a defined
            meaning (for example, enable a VM from the "marketing" department to be placed on the
            same VLAN as bare-metal marketing hosts in the same data center).</para>
        <para>The provider extension allows administrators to explicitly manage the relationship
            between Networking virtual networks and underlying physical mechanisms such as VLANs and
            tunnels. When this extension is supported, Networking client users with administrative
            privileges see additional provider attributes on all virtual networks and are able to
            specify these attributes in order to create provider networks.</para>
        <para>The provider extension is supported by the Open vSwitch and Linux Bridge plug-ins.
            Configuration of these plug-ins requires familiarity with this extension.</para>
        <section xml:id="provider_terminology">
            <title>Terminology</title>
            <para>A number of terms are used in the provider extension and in the configuration of
                plug-ins supporting the provider extension:</para>
            <table rules="all">
                <caption>Provider extension terminology</caption>
                <col width="20%"/>
                <col width="80%"/>
                <thead>
                    <tr>
                        <th>Term</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><emphasis role="bold">virtual network</emphasis></td>
                        <td>An Networking L2 network (identified by a UUID and optional name) whose
                            ports can be attached as vNICs to Compute instances and to various
                            Networking agents. The Open vSwitch and Linux Bridge plug-ins each
                            support several different mechanisms to realize virtual networks.</td>
                    </tr>
                    <tr>
                        <td><emphasis role="bold">physical network</emphasis></td>
                        <td>A network connecting virtualization hosts (such as compute nodes) with
                            each other and with other network resources. Each physical network might
                            support multiple virtual networks. The provider extension and the
                            plug-in configurations identify physical networks using simple string
                            names.</td>
                    </tr>
                    <tr>
                        <td><emphasis role="bold">tenant network</emphasis></td>
                        <td>A virtual network that a tenant or an administrator creates. The
                            physical details of the network are not exposed to the tenant.</td>
                    </tr>
                    <tr>
                        <td><emphasis role="bold">provider network</emphasis></td>
                        <td>A virtual network administratively created to map to a specific network
                            in the data center, typically to enable direct access to non-OpenStack
                            resources on that network. Tenants can be given access to provider
                            networks.</td>
                    </tr>
                    <tr>
                        <td><emphasis role="bold">VLAN network</emphasis></td>
                        <td>A virtual network implemented as packets on a specific physical network
                            containing IEEE 802.1Q headers with a specific VID field value. VLAN
                            networks sharing the same physical network are isolated from each other
                            at L2 and can even have overlapping IP address spaces. Each distinct
                            physical network supporting VLAN networks is treated as a separate VLAN
                            trunk, with a distinct space of VID values. Valid VID values are 1
                            through 4094.</td>
                    </tr>
                    <tr>
                        <td><emphasis role="bold">flat network</emphasis></td>
                        <td>A virtual network implemented as packets on a specific physical network
                            containing no IEEE 802.1Q header. Each physical network can realize at
                            most one flat network.</td>
                    </tr>
                    <tr>
                        <td><emphasis role="bold">local network</emphasis></td>
                        <td>A virtual network that allows communication within each host, but not
                            across a network. Local networks are intended mainly for single-node
                            test scenarios, but can have other uses.</td>
                    </tr>
                    <tr>
                        <td><emphasis role="bold">GRE network</emphasis></td>
                        <td>A virtual network implemented as network packets encapsulated using GRE.
                            GRE networks are also referred to as <emphasis role="italic"
                                >tunnels</emphasis>. GRE tunnel packets are routed by the IP routing
                            table for the host, so GRE networks are not associated by Networking
                            with specific physical networks.</td>
                    </tr>
                    <tr>
                        <td><emphasis role="bold">Virtual Extensible LAN (VXLAN)
                            network</emphasis></td>
                        <td>VXLAN is a proposed encapsulation protocol for running an overlay
                            network on existing Layer 3 infrastructure. An overlay network is a
                            virtual network that is built on top of existing network Layer 2 and
                            Layer 3 technologies to support elastic compute architectures.</td>
                    </tr>
                </tbody>
            </table>
            <para>The ML2, Open vSwitch, and Linux Bridge plug-ins support VLAN networks, flat
                networks, and local networks. Only the ML2 and Open vSwitch plug-ins currently
                support GRE and VXLAN networks, provided that the required features exist in the
                hosts Linux kernel, Open vSwitch, and iproute2 packages.</para>
        </section>
        <section xml:id="provider_attributes">
            <title>Provider attributes</title>
            <para>The provider extension extends the Networking network resource with these
                attributes:</para>
            <table rules="all">
                <caption>Provider network attributes</caption>
                <col width="25%"/>
                <col width="10%"/>
                <col width="25%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>provider:network_type</td>
                        <td>String</td>
                        <td>N/A</td>
                        <td>The physical mechanism by which the virtual network is implemented.
                            Possible values are <literal>flat</literal>, <literal>vlan</literal>,
                                <literal>local</literal>, and <literal>gre</literal>, corresponding
                            to flat networks, VLAN networks, local networks, and GRE networks as
                            defined above. All types of provider networks can be created by
                            administrators, while tenant networks can be implemented as
                                <literal>vlan</literal>, <literal>gre</literal>, or
                                <literal>local</literal> network types depending on plug-in
                            configuration.</td>
                    </tr>
                    <tr>
                        <td>provider:physical_network</td>
                        <td>String</td>
                        <td>If a physical network named "default" has been configured and if
                            provider:network_type is <literal>flat</literal> or
                                <literal>vlan</literal>, then "default" is used.</td>
                        <td>The name of the physical network over which the virtual network is
                            implemented for flat and VLAN networks. Not applicable to the
                                <literal>local</literal> or <literal>gre</literal> network
                            types.</td>
                    </tr>
                    <tr>
                        <td>provider:segmentation_id</td>
                        <td>Integer</td>
                        <td>N/A</td>
                        <td>For VLAN networks, the VLAN VID on the physical network that realizes
                            the virtual network. Valid VLAN VIDs are 1 through 4094. For GRE
                            networks, the tunnel ID. Valid tunnel IDs are any 32 bit unsigned
                            integer. Not applicable to the <literal>flat</literal> or
                                <literal>local</literal> network types.</td>
                    </tr>
                </tbody>
            </table>
            <para>To view or set provider extended attributes, a client must be authorized for the
                    <code>extension:provider_network:view</code> and
                    <code>extension:provider_network:set</code> actions in the Networking policy
                configuration. The default Networking configuration authorizes both actions for
                users with the admin role. An authorized client or an administrative user can view
                and set the provider extended attributes through Networking API calls. See <xref
                    linkend="section_networking_auth"/> for details on policy configuration.</para>
        </section>
        <section xml:id="provider_api_workflow">
            <title>Provider extension API operations</title>
            <para>To use the provider extension with the default policy settings, you must have the
                administrative role.</para>
            <para>This list shows example neutron commands that enable you to complete basic
                provider extension API operations:</para>
        <itemizedlist>
          <listitem>
                            <para>Shows all attributes of a network, including provider
                                attributes:</para>
                            <screen><prompt>$</prompt> <userinput>neutron net-show &lt;name or net-id&gt;</userinput></screen>
          </listitem>
          <listitem>
                            <para>Creates a local provider network:</para>
                            <screen><prompt>$</prompt> <userinput>neutron net-create &lt;name&gt; --tenant_id &lt;tenant-id&gt; --provider:network_type local</userinput></screen>
          </listitem>
          <listitem>
                            <para>When you create flat networks,
                                &lt;phys-net-name&gt; must be known to the plug-in. See the
                                    <citetitle>OpenStack
                                    Configuration Reference</citetitle> for details. Creates a flat provider network:</para>
                            <screen><prompt>$</prompt> <userinput>neutron net-create &lt;name&gt; --tenant_id &lt;tenant-id&gt; --provider:network_type flat --provider:physical_network &lt;phys-net-name&gt;</userinput></screen>
          </listitem>
          <listitem>
                            <para>When you create VLAN networks,
                                &lt;phys-net-name&gt; must be known to the plug-in. See the
                                    <citetitle>OpenStack
                                    Configuration Reference</citetitle> for details on configuring
                                network_vlan_ranges to identify all physical networks. When you
                                create VLAN networks, &lt;VID&gt; can fall either within or outside
                                any configured ranges of VLAN IDs from which tenant networks are
                                allocated. Creates a VLAN provider network:</para>
                            <screen><prompt>$</prompt> <userinput>neutron net-create &lt;name&gt; --tenant_id &lt;tenant-id&gt; --provider:network_type vlan --provider:physical_network &lt;phys-net-name&gt; --provider:segmentation_id &lt;VID&gt;</userinput></screen>
          </listitem>
          <listitem>
                            <para>When you create GRE networks,
                                &lt;tunnel-id&gt; can be either inside or outside any tunnel ID
                                ranges from which tenant networks are allocated.</para>
                            <para>After you create provider networks, you can allocate subnets,
                                which you can use in the same way as other virtual networks, subject
                                to authorization policy based on the specified
                                &lt;tenant_id&gt;. Creates a GRE provider network:</para>
                            <screen><prompt>$</prompt> <userinput>neutron net-create &lt;name&gt; --tenant_id &lt;tenant-id&gt; --provider:network_type gre --provider:segmentation_id &lt;tunnel-id&gt;</userinput></screen>
          </listitem>
        </itemizedlist>
        </section>
    </section>
    <section xml:id="section_l3_router_and_nat">
        <title>L3 routing and NAT</title>
        <para>The Networking API provides abstract L2 network segments that are decoupled from the
            technology used to implement the L2 network. Networking includes an API extension that
            provides abstract L3 routers that API users can dynamically provision and configure.
            These Networking routers can connect multiple L2 Networking networks and can also
            provide a gateway that connects one or more private L2 networks to a shared external
            network. For example, a public network for access to the
            Internet. See the <citetitle>OpenStack Configuration
            Reference</citetitle> for details on common models of
            deploying Networking L3 routers.</para>
        <para>The L3 router provides basic NAT capabilities on gateway ports that uplink the router
            to external networks. This router SNATs all traffic by default and supports floating
            IPs, which creates a static one-to-one mapping from a public IP on the external network
            to a private IP on one of the other subnets attached to the router. This allows a tenant
            to selectively expose VMs on private networks to other hosts on the external network
            (and often to all hosts on the Internet). You can allocate and map floating IPs from one
            port to another, as needed.</para>
        <?hard-pagebreak?>
        <section xml:id="l3_api_abstractions">
            <title>L3 API abstractions</title>
            <table rules="all">
                <caption>Router</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the router.</td>
                    </tr>
                    <tr>
                        <td>name</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human-readable name for the router. Might not be unique.</td>
                    </tr>
                    <tr>
                        <td>admin_state_up</td>
                        <td>Bool</td>
                        <td>True</td>
                        <td>The administrative state of router. If false (down), the router does not
                            forward packets.</td>
                    </tr>
                    <tr>
                        <td>status</td>
                        <td>String</td>
                        <td>N/A</td>
                        <td>
                            <para>Indicates whether router is currently operational.</para>
                        </td>
                    </tr>
                    <tr>
                        <td>tenant_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Owner of the router. Only admin users can specify a tenant_id other than
                            its own.</td>
                    </tr>
                    <tr>
                        <td>external_gateway_info</td>
                        <td>dict contain 'network_id' key-value pair</td>
                        <td>Null</td>
                        <td>External network that this router connects to for gateway services (for
                            example, NAT)</td>
                    </tr>
                </tbody>
            </table>
            <table rules="all">
                <caption>Floating IP</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the floating IP.</td>
                    </tr>
                    <tr>
                        <td>floating_ip_address</td>
                        <td>string (IP address)</td>
                        <td>allocated by Networking</td>
                        <td>The external network IP address available to be mapped to an internal IP
                            address.</td>
                    </tr>
                    <tr>
                        <td>floating_network_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>
                            <para>The network indicating the set of subnets from which the floating
                                IP should be allocated</para>
                        </td>
                    </tr>
                    <tr>
                        <td>router_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Read-only value indicating the router that connects the external network
                            to the associated internal port, if a port is associated.</td>
                    </tr>
                    <tr>
                        <td>port_id</td>
                        <td>uuid-str</td>
                        <td>Null</td>
                        <td>Indicates the internal Networking port associated with the external
                            floating IP.</td>
                    </tr>
                    <tr>
                        <td>fixed_ip_address</td>
                        <td>string (IP address)</td>
                        <td>Null</td>
                        <td>Indicates the IP address on the internal port that is mapped to by the
                            floating IP (since an Networking port might have more than one IP
                            address).</td>
                    </tr>
                    <tr>
                        <td>tenant_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Owner of the Floating IP. Only admin users can specify a tenant_id other
                            than its own.</td>
                    </tr>
                </tbody>
            </table>
        </section>
        <?hard-pagebreak?>
        <section xml:id="l3_workflow">
            <title>Basic L3 operations</title>
            <para>External networks are visible to all users. However, the default policy settings
                enable only administrative users to create, update, and delete external
                networks.</para>
            <para>This table shows example neutron commands that enable you to complete basic L3
                operations:</para>
            <table rules="all">
                <caption>Basic L3 operations</caption>
                <col width="40%"/>
                <col width="60%"/>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Command</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <para>Creates external networks.</para>
                        </td>
                        <td>
                            <screen><prompt>#</prompt> <userinput>neutron net-create public --router:external=True</userinput>
<prompt>$</prompt> <userinput>neutron subnet-create public 172.16.1.0/24</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Lists external networks.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron net-list -- --router:external=True</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Creates an internal-only router that connects to multiple L2
                                networks privately.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron net-create net1</userinput>
<prompt>$</prompt> <userinput>neutron subnet-create net1 10.0.0.0/24</userinput>
<prompt>$</prompt> <userinput>neutron net-create net2</userinput>
<prompt>$</prompt> <userinput>neutron subnet-create net2 10.0.1.0/24</userinput>
<prompt>$</prompt> <userinput>neutron router-create router1</userinput>
<prompt>$</prompt> <userinput>neutron router-interface-add router1 &lt;subnet1-uuid&gt;</userinput>
<prompt>$</prompt> <userinput>neutron router-interface-add router1 &lt;subnet2-uuid&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Connects a router to an external network, which enables that
                                router to act as a NAT gateway for external connectivity.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron router-gateway-set router1 &lt;ext-net-id&gt;</userinput></screen>
                            <para>The router obtains an interface with the gateway_ip address of the
                                subnet and this interface is attached to a port on the L2
                                Networking network associated with the subnet. The router also gets
                                a gateway interface to the specified external network. This provides
                                SNAT connectivity to the external network as well as support for
                                floating IPs allocated on that external networks. Commonly an
                                external network maps to a network in the provider</para>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Lists routers.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron router-list</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Shows information for a specified router.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron router-show &lt;router_id&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Shows all internal interfaces for a router.</para>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Identifies the <literal>port-id</literal> that represents the VM
                                NIC to which the floating IP should map.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron port-list -c id -c fixed_ips -- --device_id=&lt;instance_id&gt;</userinput></screen>
                            <para>This port must be on an Networking subnet that is attached to a
                                router uplinked to the external network used to create the floating
                                IP. Conceptually, this is because the router must be able to perform
                                the Destination NAT (DNAT) rewriting of packets from the Floating IP
                                address (chosen from a subnet on the external network) to the
                                internal Fixed IP (chosen from a private subnet that is behind the
                                router).</para>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Creates a floating IP address and associates it with a
                                port.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron floatingip-create &lt;ext-net-id&gt;</userinput>
<prompt>$</prompt> <userinput>neutron floatingip-associate &lt;floatingip-id&gt; &lt;internal VM port-id&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Creates a floating IP address and associates it with a port, in a
                                single step.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron floatingip-create --port_id &lt;internal VM port-id&gt; &lt;ext-net-id&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Lists floating IPs.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron floatingip-list</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Finds floating IP for a specified VM port.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron floatingip-list -- --port_id=ZZZ</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Disassociates a floating IP address.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron floatingip-disassociate &lt;floatingip-id&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Deletes the floating IP address.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron floatingip-delete &lt;floatingip-id&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Clears the gateway.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron router-gateway-clear router1</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Removes the interfaces from the router.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron router-interface-delete router1 &lt;subnet-id&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Deletes the router.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron router-delete router1</userinput></screen>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>
    <?hard-pagebreak?>
    <section xml:id="section_securitygroups">
        <title>Security groups</title>
        <para>Security groups and security group rules allows administrators and tenants the ability
            to specify the type of traffic and direction (ingress/egress) that is allowed to pass
            through a port. A security group is a container for security group rules.</para>
        <para>When a port is created in Networking it is associated with a security group. If a
            security group is not specified the port is associated with a 'default' security group.
            By default, this group drops all ingress traffic and allows all egress. Rules can be
            added to this group in order to change the behaviour.</para>
        <para>To use the Compute security group APIs or use Compute to orchestrate the creation of
            ports for instances on specific security groups, you must complete additional
            configuration. You must configure the <filename>/etc/nova/nova.conf</filename> file and
            set the <code>security_group_api=neutron</code> option on every node that runs
                <systemitem class="service">nova-compute</systemitem> and <systemitem
                class="service">nova-api</systemitem>. After you make this change, restart
                <systemitem class="service">nova-api</systemitem> and <systemitem class="service"
                >nova-compute</systemitem> to pick up this change. Then, you can use both the
            Compute and OpenStack Network security group APIs at the same time.</para>
        <note>
            <itemizedlist>
                <listitem>
                    <para>To use the Compute security group API with Networking, the Networking
                        plug-in must implement the security group API. The following plug-ins
                        currently implement this: ML2, Open vSwitch, Linux Bridge, NEC, Ryu, and
                        VMware NSX.</para>
                </listitem>
                <listitem>
                    <para>You must configure the correct firewall driver in the
                            <literal>securitygroup</literal> section of the plug-in/agent
                        configuration file. Some plug-ins and agents, such as Linux Bridge Agent and
                        Open vSwitch Agent, use the no-operation driver as the default, which
                        results in non-working security groups.</para>
                </listitem>
                <listitem>
                    <para>When using the security group API through Compute, security groups are
                        applied to all ports on an instance. The reason for this is that Compute
                        security group APIs are instances based and not port based as
                        Networking.</para>
                </listitem>
            </itemizedlist>
        </note>
        <section xml:id="securitygroup_api_abstractions">
            <title>Security group API abstractions</title>
            <table rules="all">
                <caption>Security group attributes</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the security group.</td>
                    </tr>
                    <tr>
                        <td>name</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human-readable name for the security group. Might not be unique. Cannot
                            be named default as that is automatically created for a tenant.</td>
                    </tr>
                    <tr>
                        <td>description</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human-readable description of a security group.</td>
                    </tr>
                    <tr>
                        <td>tenant_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Owner of the security group. Only admin users can specify a tenant_id
                            other than their own.</td>
                    </tr>
                </tbody>
            </table>
            <table rules="all">
                <caption>Security group rules</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the security group rule.</td>
                    </tr>
                    <tr>
                        <td>security_group_id</td>
                        <td>uuid-str or Integer</td>
                        <td>allocated by Networking</td>
                        <td>The security group to associate rule with.</td>
                    </tr>
                    <tr>
                        <td>direction</td>
                        <td>String</td>
                        <td>N/A</td>
                        <td>The direction the traffic is allow (ingress/egress) from a VM.</td>
                    </tr>
                    <tr>
                        <td>protocol</td>
                        <td>String</td>
                        <td>None</td>
                        <td>IP Protocol (icmp, tcp, udp, and so on).</td>
                    </tr>
                    <tr>
                        <td>port_range_min</td>
                        <td>Integer</td>
                        <td>None</td>
                        <td>Port at start of range</td>
                    </tr>
                    <tr>
                        <td>port_range_max</td>
                        <td>Integer</td>
                        <td>None</td>
                        <td>Port at end of range</td>
                    </tr>
                    <tr>
                        <td>ethertype</td>
                        <td>String</td>
                        <td>None</td>
                        <td>ethertype in L2 packet (IPv4, IPv6, and so on)</td>
                    </tr>
                    <tr>
                        <td>remote_ip_prefix</td>
                        <td>string (IP cidr)</td>
                        <td>None</td>
                        <td>CIDR for address range</td>
                    </tr>
                    <tr>
                        <td>remote_group_id</td>
                        <td>uuid-str or Integer</td>
                        <td>allocated by Networking or Compute</td>
                        <td>Source security group to apply to rule.</td>
                    </tr>
                    <tr>
                        <td>tenant_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Owner of the security group rule. Only admin users can specify a
                            tenant_id other than its own.</td>
                    </tr>
                </tbody>
            </table>
        </section>
        <section xml:id="securitygroup_workflow">
            <title>Basic security group operations</title>
            <para>This table shows example neutron commands that enable you to complete basic
                security group operations:</para>
            <table rules="all">
                <caption>Basic security group operations</caption>
                <col width="40%"/>
                <col width="60%"/>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Command</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <para>Creates a security group for our web servers.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron security-group-create webservers --description "security group for webservers"</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Lists security groups.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron security-group-list</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Creates a security group rule to allow port 80 ingress.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron security-group-rule-create --direction ingress --protocol tcp --port_range_min 80 --port_range_max 80 &lt;security_group_uuid&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Lists security group rules.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron security-group-rule-list</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Deletes a security group rule.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron security-group-rule-delete &lt;security_group_rule_uuid&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Deletes a security group.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron security-group-delete &lt;security_group_uuid&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Creates a port and associates two security groups.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron port-create --security-group &lt;security_group_id1&gt; --security-group &lt;security_group_id2&gt; &lt;network_id&gt;</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Removes security groups from a port.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron port-update --no-security-groups &lt;port_id&gt;</userinput></screen>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>
    <?hard-pagebreak?>
    <section xml:id="lbaas_workflow">
        <title>Basic Load-Balancer-as-a-Service operations</title>
        <note>
            <para>The Load-Balancer-as-a-Service (LBaaS) API provisions and configures load
                balancers. The Havana release offers a reference implementation that is based on the
                HAProxy software load balancer.</para>
        </note>
        <para>This list shows example neutron commands that enable you to complete basic LBaaS
            operations:</para>
        <itemizedlist>
          <listitem>
                        <para>Creates a load balancer pool by using specific provider.</para>
                        <para><parameter>--provider</parameter> is an optional argument. If not
                            used, the pool is created with default provider for LBaaS service. You
                            should configure the default provider in the
                                <literal>[service_providers]</literal> section of
                                <filename>neutron.conf</filename> file. If no default provider is
                            specified for LBaaS, the <parameter>--provider</parameter> option is
                            required for pool creation.</para>
                        <screen><prompt>$</prompt> <userinput>neutron lb-pool-create --lb-method ROUND_ROBIN --name mypool --protocol HTTP --subnet-id &lt;subnet-uuid&gt; <parameter>--provider &lt;provider_name&gt;</parameter></userinput></screen>
          </listitem>
          <listitem>
                        <para>Associates two web servers with pool.</para>
                        <screen><prompt>$</prompt> <userinput>neutron lb-member-create --address  &lt;webserver one IP&gt; --protocol-port 80 mypool</userinput>
<prompt>$</prompt> <userinput>neutron lb-member-create --address  &lt;webserver two IP&gt; --protocol-port 80 mypool</userinput></screen>
          </listitem>
          <listitem>
                        <para>Creates a health monitor which checks to make sure our instances are
                            still running on the specified protocol-port.</para>
                        <screen><prompt>$</prompt> <userinput>neutron lb-healthmonitor-create --delay 3 --type HTTP --max-retries 3 --timeout 3</userinput></screen>
          </listitem>
          <listitem>
                        <para>Associates a health monitor with pool.</para>
                        <screen><prompt>$</prompt> <userinput>neutron lb-healthmonitor-associate  &lt;healthmonitor-uuid&gt; mypool</userinput></screen>
          </listitem>
          <listitem>
                        <para>Creates a virtual IP (VIP) address that, when accessed through the
                            load balancer, directs the requests to one of the pool members.</para>
                        <screen><prompt>$</prompt> <userinput>neutron lb-vip-create --name myvip --protocol-port 80 --protocol HTTP --subnet-id &lt;subnet-uuid&gt; mypool</userinput></screen>
          </listitem>
        </itemizedlist>
    </section>
    <?hard-pagebreak?>
    <section xml:id="fwaas">
        <title>Firewall-as-a-Service</title>
        <para>The Firewall-as-a-Service (FWaaS) API is an experimental API that enables early
            adopters and vendors to test their networking implementations.</para>
        <section xml:id="fwaas_api_abstractions">
            <title>Firewall-as-a-Service API abstractions</title>
            <table rules="all">
                <caption>Firewall rules</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the firewall rule.</td>
                    </tr>
                    <tr>
                        <td>tenant_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Owner of the firewall rule. Only admin users can specify a tenant_id
                            other than its own.</td>
                    </tr>
                    <tr>
                        <td>name</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human readable name for the firewall rule (255 characters limit).</td>
                    </tr>
                    <tr>
                        <td>description</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human readable description for the firewall rule (1024 characters
                            limit).</td>
                    </tr>
                    <tr>
                        <td>firewall_policy_id</td>
                        <td>uuid-str or None</td>
                        <td>allocated by Networking</td>
                        <td>This is a read-only attribute that gets populated with the uuid of the
                            firewall policy when this firewall rule is associated with a firewall
                            policy. A firewall rule can be associated with only one firewall policy
                            at a time. However, the association can be changed to a different
                            firewall policy.</td>
                    </tr>
                    <tr>
                        <td>shared</td>
                        <td>Boolean</td>
                        <td>False</td>
                        <td>When set to True makes this firewall rule visible to tenants other than
                            its owner and it can be used in firewall policies not owned by its
                            tenant.</td>
                    </tr>
                    <tr>
                        <td>protocol</td>
                        <td>String</td>
                        <td>None</td>
                        <td>IP Protocol (icmp, tcp, udp, None).</td>
                    </tr>
                    <tr>
                        <td>ip_version</td>
                        <td>Integer or String</td>
                        <td>4</td>
                        <td>IP Version (4, 6).</td>
                    </tr>
                    <tr>
                        <td>source_ip_address</td>
                        <td>String (IP address or CIDR)</td>
                        <td>None</td>
                        <td>Source IP address or CIDR.</td>
                    </tr>
                    <tr>
                        <td>destination_ip_address</td>
                        <td>String (IP address or CIDR)</td>
                        <td>None</td>
                        <td>Destination IP address or CIDR.</td>
                    </tr>
                    <tr>
                        <td>source_port</td>
                        <td>Integer or String (either as a single port number or in the format of a
                            ':' separated range)</td>
                        <td>None</td>
                        <td>Source port number or a range.</td>
                    </tr>
                    <tr>
                        <td>destination_port</td>
                        <td>Integer or String (either as a single port number or in the format of a
                            ':' separated range)</td>
                        <td>None</td>
                        <td>Destination port number or a range.</td>
                    </tr>
                    <tr>
                        <td>position</td>
                        <td>Integer</td>
                        <td>None</td>
                        <td>This is a read-only attribute that gets assigned to this rule when the
                            rule is associated with a firewall policy. It indicates the position of
                            this rule in that firewall policy.</td>
                    </tr>
                    <tr>
                        <td>action</td>
                        <td>String</td>
                        <td>deny</td>
                        <td>Action to be performed on the traffic matching the rule (allow,
                            deny).</td>
                    </tr>
                    <tr>
                        <td>enabled</td>
                        <td>Boolean</td>
                        <td>True</td>
                        <td>When set to False, disables this rule in the firewall policy.
                            Facilitates selectively turning off rules without having to disassociate
                            the rule from the firewall policy.</td>
                    </tr>
                </tbody>
            </table>
            <table rules="all">
                <caption>Firewall policies</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the firewall policy.</td>
                    </tr>
                    <tr>
                        <td>tenant_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Owner of the firewall policy. Only admin users can specify a tenant_id
                            other their own.</td>
                    </tr>
                    <tr>
                        <td>name</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human readable name for the firewall policy (255 characters limit).</td>
                    </tr>
                    <tr>
                        <td>description</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human readable description for the firewall policy (1024 characters
                            limit).</td>
                    </tr>
                    <tr>
                        <td>shared</td>
                        <td>Boolean</td>
                        <td>False</td>
                        <td>When set to True makes this firewall policy visible to tenants other
                            than its owner and can be used to associate with firewalls not owned by
                            its tenant.</td>
                    </tr>
                    <tr>
                        <td>firewall_rules</td>
                        <td>List of uuid-str or None</td>
                        <td>None</td>
                        <td>This is an ordered list of firewall rule uuids. The firewall applies the
                            rules in the order in which they appear in this list.</td>
                    </tr>
                    <tr>
                        <td>audited</td>
                        <td>Boolean</td>
                        <td>False</td>
                        <td>When set to True by the policy owner indicates that the firewall policy
                            has been audited. This attribute is meant to aid in the firewall policy
                            audit workflows. Each time the firewall policy or the associated
                            firewall rules are changed, this attribute is set to False and must be
                            explicitly set to True through an update operation.</td>
                    </tr>
                </tbody>
            </table>
            <table rules="all">
                <caption>Firewalls</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the firewall.</td>
                    </tr>
                    <tr>
                        <td>tenant_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Owner of the firewall. Only admin users can specify a tenant_id other
                            than its own.</td>
                    </tr>
                    <tr>
                        <td>name</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human readable name for the firewall (255 characters limit).</td>
                    </tr>
                    <tr>
                        <td>description</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human readable description for the firewall (1024 characters
                            limit).</td>
                    </tr>
                    <tr>
                        <td>admin_state_up</td>
                        <td>Boolean</td>
                        <td>True</td>
                        <td>The administrative state of the firewall. If False (down), the firewall
                            does not forward any packets.</td>
                    </tr>
                    <tr>
                        <td>status</td>
                        <td>String</td>
                        <td>N/A</td>
                        <td>
                            <para>Indicates whether the firewall is currently operational. Possible
                                values include:</para>
                            <itemizedlist>
                                <listitem>
                                    <para>ACTIVE</para>
                                </listitem>
                                <listitem>
                                    <para>DOWN</para>
                                </listitem>
                                <listitem>
                                    <para>PENDING_CREATE</para>
                                </listitem>
                                <listitem>
                                    <para>PENDING_UPDATE</para>
                                </listitem>
                                <listitem>
                                    <para>PENDING_DELETE</para>
                                </listitem>
                                <listitem>
                                    <para>ERROR</para>
                                </listitem>
                            </itemizedlist>
                        </td>
                    </tr>
                    <tr>
                        <td>firewall_policy_id</td>
                        <td>uuid-str or None</td>
                        <td>None</td>
                        <td>The firewall policy uuid that this firewall is associated with. This
                            firewall implements the rules contained in the firewall policy
                            represented by this uuid.</td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>
    <?hard-pagebreak?>
    <section xml:id="section_plugin_specific_extensions">
        <title>Plug-in specific extensions</title>
        <?dbhtml stop-chunking?>
        <para>Each vendor can choose to implement additional API extensions to the core API. This
            section describes the extensions for each plug-in.</para>
        <section xml:id="section_vmware_extensions">
            <title>VMware NSX extensions</title>
            <para>These sections explain NSX plug-in extensions.</para>
            <section xml:id="section_vmware_nsx_plugin_qos_extension">
                <title>VMware NSX QoS extension</title>
                <para>The VMware NSX QoS extension rate-limits network ports to guarantee a specific
                    amount of bandwidth for each port. This extension, by default, is only
                    accessible by a tenant with an admin role but is configurable through the
                        <filename>policy.json</filename> file. To use this extension, create a queue
                    and specify the min/max bandwidth rates (kbps) and optionally set the QoS
                    Marking and DSCP value (if your network fabric uses these values to make
                    forwarding decisions). Once created, you can associate a queue with a network.
                    Then, when ports are created on that network they are automatically created and
                    associated with the specific queue size that was associated with the network.
                    Because one size queue for a every port on a network might not be optimal, a
                    scaling factor from the nova flavor 'rxtx_factor' is passed in from Compute when
                    creating the port to scale the queue.</para>
                <para>Lastly, if you want to set a specific baseline QoS policy for the amount of
                    bandwidth a single port can use (unless a network queue is specified with the
                    network a port is created on) a default queue can be created in Networking which
                    then causes ports created to be associated with a queue of that size times the
                    rxtx scaling factor. Note that after a network or default queue is specified,
                    queues are added to ports that are subsequently created but are not added to
                    existing ports.</para>
                <section xml:id="section_vmware_nsx_qos_api_abstractions">
                    <title>VMware NSX QoS API abstractions</title>
                    <table rules="all">
                        <caption>VMware NSX QoS attributes</caption>
                        <col width="20%"/>
                        <col width="20%"/>
                        <col width="20%"/>
                        <col width="40%"/>
                        <thead>
                            <tr>
                                <th>Attribute name</th>
                                <th>Type</th>
                                <th>Default Value</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>id</td>
                                <td>uuid-str</td>
                                <td>generated</td>
                                <td>UUID for the QoS queue.</td>
                            </tr>
                            <tr>
                                <td>default</td>
                                <td>Boolean</td>
                                <td>False by default</td>
                                <td>If True, ports are created with this queue size unless the
                                    network port is created or associated with a queue at port
                                    creation time.</td>
                            </tr>
                            <tr>
                                <td>name</td>
                                <td>String</td>
                                <td>None</td>
                                <td>Name for QoS queue.</td>
                            </tr>
                            <tr>
                                <td>min</td>
                                <td>Integer</td>
                                <td>0</td>
                                <td>Minimum Bandwidth Rate (kbps).</td>
                            </tr>
                            <tr>
                                <td>max</td>
                                <td>Integer</td>
                                <td>N/A</td>
                                <td>Maximum Bandwidth Rate (kbps).</td>
                            </tr>
                            <tr>
                                <td>qos_marking</td>
                                <td>String</td>
                                <td>untrusted by default</td>
                                <td>Whether QoS marking should be trusted or untrusted.</td>
                            </tr>
                            <tr>
                                <td>dscp</td>
                                <td>Integer</td>
                                <td>0</td>
                                <td>DSCP Marking value.</td>
                            </tr>
                            <tr>
                                <td>tenant_id</td>
                                <td>uuid-str</td>
                                <td>N/A</td>
                                <td>The owner of the QoS queue.</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
                <section xml:id="vmware_nsx_qos_walk_through">
                    <title>Basic VMware NSX QoS operations</title>
                    <para>This table shows example neutron commands that enable you to complete
                        basic queue operations:</para>
                    <table rules="all">
                        <caption>Basic VMware NSX QoS operations</caption>
                        <col width="40%"/>
                        <col width="60%"/>
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Command</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <para>Creates QoS Queue (admin-only).</para>
                                </td>
                                <td>
                                    <screen><prompt>$</prompt> <userinput>neutron queue-create--min 10 --max 1000 myqueue</userinput></screen>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <para>Associates a queue with a network.</para>
                                </td>
                                <td>
                                    <screen><prompt>$</prompt> <userinput>neutron net-create network --queue_id=&lt;queue_id&gt;</userinput></screen>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <para>Creates a default system queue.</para>
                                </td>
                                <td>
                                    <screen><prompt>$</prompt> <userinput>neutron queue-create --default True --min 10 --max 2000 default</userinput></screen>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <para>Lists QoS queues.</para>
                                </td>
                                <td>
                                    <screen><prompt>$</prompt> <userinput>neutron queue-list</userinput></screen>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <para>Deletes a QoS queue.</para>
                                </td>
                                <td>
                                    <screen><prompt>$</prompt> <userinput>neutron queue-delete &lt;queue_id or name&gt;'</userinput></screen>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </section>
            </section>
            <section xml:id="section_vmware_nsx_provider_extension">
                <title>VMware NSX provider networks extension</title>
                <para>Provider networks can be implemented in different ways by the underlying NSX
                    platform.</para>
                <para>The <emphasis>FLAT</emphasis> and <emphasis>VLAN</emphasis> network types use
                    bridged transport connectors. These network types enable the attachment of large
                    number of ports. To handle the increased scale, the NSX plug-in can back a
                    single OpenStack Network with a chain of NSX logical switches. You can specify
                    the maximum number of ports on each logical switch in this chain on the
                        <literal>max_lp_per_bridged_ls</literal> parameter, which has a default
                    value of 5,000.</para>
                <para>The recommended value for this parameter varies with the NSX version running
                    in the back-end, as shown in the following table.</para>
                <table rules="all">
                    <caption>Recommended values for max_lp_per_bridged_ls</caption>
                    <col width="50%"/>
                    <col width="50%"/>
                    <thead>
                        <tr>
                            <td>NSX version</td>
                            <td>Recommended Value</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>2.x</td>
                            <td>64</td>
                        </tr>
                        <tr>
                            <td>3.0.x</td>
                            <td>5,000</td>
                        </tr>
                        <tr>
                            <td>3.1.x</td>
                            <td>5,000</td>
                        </tr>
                        <tr>
                            <td>3.2.x</td>
                            <td>10,000</td>
                        </tr>
                    </tbody>
                </table>
                <para>In addition to these network types, the NSX plug-in also supports a special
                        <emphasis>l3_ext</emphasis> network type, which maps external networks to
                    specific NSX gateway services as discussed in the next section.</para>
            </section>
            <section xml:id="section_vmware_nsx_plugin_l3_extension">
                <title>VMware NSX L3 extension</title>
                <para>NSX exposes its L3 capabilities through gateway services which are usually
                    configured out of band from OpenStack. To use NSX with L3 capabilities, first
                    create a L3 gateway service in the NSX Manager. Next, in <filename>
                        /etc/neutron/plugins/vmware/nsx.ini</filename> set
                        <literal>default_l3_gw_service_uuid</literal> to this value. By default,
                    routers are mapped to this gateway service.</para>
                <section xml:id="section_vmware_l3_walk_through">
                    <title>VMware NSX L3 extension operations</title>
                    <para>Create external network and map it to a specific NSX gateway
                        service:</para>
                    <screen><prompt>$</prompt> <userinput>neutron net-create public --router:external=True --provider:network_type l3_ext \
--provider:physical_network &lt;L3-Gateway-Service-UUID&gt;</userinput></screen>
                    <para>Terminate traffic on a specific VLAN from a NSX gateway service:</para>
                    <screen><prompt>$</prompt> <userinput>neutron net-create public --router:external=True --provider:network_type l3_ext \
--provider:physical_network &lt;L3-Gateway-Service-UUID&gt; --provider:segmentation_id &lt;VLAN_ID&gt;</userinput></screen>
                </section>
            </section>
            <section xml:id="section_vmware_nsx_plugin_status_sync">
                <title>Operational status synchronization in the VMware NSX plug-in</title>
                <para>Starting with the Havana release, the VMware NSX plug-in provides an
                    asynchronous mechanism for retrieving the operational status for neutron
                    resources from the NSX back-end; this applies to <emphasis>network</emphasis>,
                        <emphasis>port</emphasis> and <emphasis>router</emphasis> resources.</para>
                <para>The back-end is polled periodically and the status for every resource is
                    retrieved; then the status in the Networking database is updated only for the
                    resources for which a status change occurred. As operational status is now
                    retrieved asynchronously, performance for <literal>GET</literal> operations is
                    consistently improved.</para>
                <para>Data to retrieve from the back-end are divided in chunks in order to avoid
                    expensive API requests; this is achieved leveraging NSX APIs response paging
                    capabilities. The minimum chunk size can be specified using a configuration
                    option; the actual chunk size is then determined dynamically according to: total
                    number of resources to retrieve, interval between two synchronization task runs,
                    minimum delay between two subsequent requests to the NSX back-end.</para>
                <para>The operational status synchronization can be tuned or disabled using the
                    configuration options reported in this table; it is however worth noting that
                    the default values work fine in most cases.</para>
                <table rules="all">
                    <caption>Configuration options for tuning operational status synchronization in
                        the NSX plug-in</caption>
                    <col width="12%"/>
                    <col width="8%"/>
                    <col width="10%"/>
                    <col width="20%"/>
                    <col width="50%"/>
                    <thead>
                        <tr>
                            <th>Option name</th>
                            <th>Group</th>
                            <th>Default value</th>
                            <th>Type and constraints</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><literal>state_sync_interval</literal></td>
                            <td><literal>nsx_sync</literal></td>
                            <td>120 seconds</td>
                            <td>Integer; no constraint.</td>
                            <td>Interval in seconds between two run of the synchronization task. If
                                the synchronization task takes more than
                                    <literal>state_sync_interval</literal> seconds to execute, a new
                                instance of the task is started as soon as the other is completed.
                                Setting the value for this option to 0 will disable the
                                synchronization task.</td>
                        </tr>
                        <tr>
                            <td><literal>max_random_sync_delay</literal></td>
                            <td><literal>nsx_sync</literal></td>
                            <td>0 seconds</td>
                            <td>Integer. Must not exceed <literal>min_sync_req_delay</literal></td>
                            <td>When different from zero, a random delay between 0 and
                                    <literal>max_random_sync_delay</literal> will be added before
                                processing the next chunk.</td>
                        </tr>
                        <tr>
                            <td><literal>min_sync_req_delay</literal></td>
                            <td><literal>nsx_sync</literal></td>
                            <td>10 seconds</td>
                            <td>Integer. Must not exceed
                                <literal>state_sync_interval</literal>.</td>
                            <td>The value of this option can be tuned according to the observed load
                                on the NSX controllers. Lower values will result in faster
                                synchronization, but might increase the load on the controller
                                cluster.</td>
                        </tr>
                        <tr>
                            <td><literal>min_chunk_size</literal></td>
                            <td><literal>nsx_sync</literal></td>
                            <td>500 resources</td>
                            <td>Integer; no constraint.</td>
                            <td>Minimum number of resources to retrieve from the back-end for each
                                synchronization chunk. The expected number of synchronization chunks
                                is given by the ratio between <literal>state_sync_interval</literal>
                                and <literal>min_sync_req_delay</literal>. This size of a chunk
                                might increase if the total number of resources is such that more
                                than <literal>min_chunk_size</literal> resources must be fetched in
                                one chunk with the current number of chunks.</td>
                        </tr>
                        <tr>
                            <td><literal>always_read_status</literal></td>
                            <td><literal>nsx_sync</literal></td>
                            <td>False</td>
                            <td>Boolean; no constraint.</td>
                            <td>When this option is enabled, the operational status will always be
                                retrieved from the NSX back-end ad every <literal>GET</literal>
                                request. In this case it is advisable to disable the synchronization
                                task.</td>
                        </tr>
                    </tbody>
                </table>
                <para>When running multiple OpenStack Networking server instances, the status
                    synchronization task should not run on every node; doing so sends unnecessary
                    traffic to the NSX back-end and performs unnecessary DB operations. Set the
                        <option>state_sync_interval</option> configuration option to a non-zero
                    value exclusively on a node designated for back-end status
                    synchronization.</para>
                <para>The <parameter>fields=status</parameter> parameter in Networking API requests
                    always triggers an explicit query to the NSX back end, even when you enable
                    asynchronous state synchronization. For example, <code>GET
                        /v2.0/networks/&lt;net-id>?fields=status&amp;fields=name</code>.</para>
            </section>
        </section>
        <section xml:id="section_bigswitch_extensions">
            <title>Big Switch plug-in extensions</title>
            <para>This section explains the Big Switch neutron plug-in-specific extension.</para>
            <section xml:id="section_bigswitch_extension_routerrules">
                <title>Big Switch router rules</title>
                <para>Big Switch allows router rules to be added to each tenant router. These rules
                    can be used to enforce routing policies such as denying traffic between subnets
                    or traffic to external networks. By enforcing these at the router level, network
                    segmentation policies can be enforced across many VMs that have differing
                    security groups.</para>
                <section xml:id="section_bigswitch_routerrule_fields">
                    <title>Router rule attributes</title>
                    <para>Each tenant router has a set of router rules associated with it. Each
                        router rule has the attributes in this table. Router rules and their
                        attributes can be set using the <command>neutron router-update</command>
                        command, through the horizon interface or the Networking API.</para>
                    <table rules="all">
                        <caption>Big Switch Router rule attributes</caption>
                        <col width="20%"/>
                        <col width="15%"/>
                        <col width="25%"/>
                        <col width="40%"/>
                        <thead>
                            <tr>
                                <th>Attribute name</th>
                                <th>Required</th>
                                <th>Input Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>source</td>
                                <td>Yes</td>
                                <td>A valid CIDR or one of the keywords 'any' or 'external'</td>
                                <td>The network that a packet's source IP must match for the rule to
                                    be applied</td>
                            </tr>
                            <tr>
                                <td>destination</td>
                                <td>Yes</td>
                                <td>A valid CIDR or one of the keywords 'any' or 'external'</td>
                                <td>The network that a packet's destination IP must match for the
                                    rule to be applied</td>
                            </tr>
                            <tr>
                                <td>action</td>
                                <td>Yes</td>
                                <td>'permit' or 'deny'</td>
                                <td>Determines whether or not the matched packets will allowed to
                                    cross the router</td>
                            </tr>
                            <tr>
                                <td>nexthop</td>
                                <td>No</td>
                                <td>A plus-separated (+) list of next-hop IP addresses. For example,
                                        <literal>1.1.1.1+1.1.1.2</literal>.</td>
                                <td>Overrides the default virtual router used to handle traffic for
                                    packets that match the rule</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
                <section xml:id="section_bigswitch_routerrule_processorder">
                    <title>Order of rule processing</title>
                    <para>The order of router rules has no effect. Overlapping rules are evaluated
                        using longest prefix matching on the source and destination fields. The
                        source field is matched first so it always takes higher precedence over the
                        destination field. In other words, longest prefix matching is used on the
                        destination field only if there are multiple matching rules with the same
                        source.</para>
                </section>
                <section xml:id="section_bigswitch_routerrule_walkthrough">
                    <title>Big Switch router rules operations</title>
                    <para>Router rules are configured with a router update operation in OpenStack
                        Networking. The update overrides any previous rules so all rules must be
                        provided at the same time.</para>
                    <para>Update a router with rules to permit traffic by default but block traffic
                        from external networks to the 10.10.10.0/24 subnet:</para>
                    <screen><prompt>$</prompt> <userinput>neutron router-update <replaceable>Router-UUID</replaceable> --router_rules type=dict list=true\
source=any,destination=any,action=permit \
source=external,destination=10.10.10.0/24,action=deny</userinput></screen>
                    <para>Specify alternate next-hop addresses for a specific subnet:</para>
                    <screen><prompt>$</prompt> <userinput>neutron router-update <replaceable>Router-UUID</replaceable> --router_rules type=dict list=true\
source=any,destination=any,action=permit \
source=10.10.10.0/24,destination=any,action=permit,nexthops=10.10.10.254+10.10.10.253</userinput></screen>
                    <para>Block traffic between two subnets while allowing everything else:</para>
                    <screen><prompt>$</prompt> <userinput>neutron router-update <replaceable>Router-UUID</replaceable> --router_rules type=dict list=true\
source=any,destination=any,action=permit \
source=10.10.10.0/24,destination=10.20.20.20/24,action=deny</userinput></screen>
                </section>
            </section>
        </section>
    </section>
    <section xml:id="metering">
        <title>L3 metering</title>
        <para>The L3 metering API extension enables administrators to configure IP ranges and assign
            a specified label to them to be able to measure traffic that goes through a virtual
            router.</para>
        <para>The L3 metering extension is decoupled from the technology that implements the
            measurement. Two abstractions have been added: One is the metering label that can
            contain metering rules. Because a metering label is associated with a tenant, all
            virtual routers in this tenant are associated with this label.</para>
        <section xml:id="metering_abstraction">
            <title>L3 metering API abstractions</title>
            <table rules="all">
                <caption>Label</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the metering label.</td>
                    </tr>
                    <tr>
                        <td>name</td>
                        <td>String</td>
                        <td>None</td>
                        <td>Human-readable name for the metering label. Might not be unique.</td>
                    </tr>
                    <tr>
                        <td>description</td>
                        <td>String</td>
                        <td>None</td>
                        <td>The optional description for the metering label.</td>
                    </tr>
                    <tr>
                        <td>tenant_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>Owner of the metering label.</td>
                    </tr>
                </tbody>
            </table>
            <table rules="all">
                <caption>Rules</caption>
                <col width="20%"/>
                <col width="20%"/>
                <col width="20%"/>
                <col width="40%"/>
                <thead>
                    <tr>
                        <th>Attribute name</th>
                        <th>Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>id</td>
                        <td>uuid-str</td>
                        <td>generated</td>
                        <td>UUID for the metering rule.</td>
                    </tr>
                    <tr>
                        <td>direction</td>
                        <td>String (Either ingress or egress)</td>
                        <td>ingress</td>
                        <td>The direction in which metering rule is applied, either ingress or
                            egress.</td>
                    </tr>
                    <tr>
                        <td>metering_label_id</td>
                        <td>uuid-str</td>
                        <td>N/A</td>
                        <td>
                            <para>The metering label ID to associate with this metering rule.</para>
                        </td>
                    </tr>
                    <tr>
                        <td>excluded</td>
                        <td>Boolean</td>
                        <td>False</td>
                        <td>Specify whether the remote_ip_prefix will be excluded or not from
                            traffic counters of the metering label (for example, to not count the
                            traffic of a specific IP address of a range).</td>
                    </tr>
                    <tr>
                        <td>remote_ip_prefix</td>
                        <td>String (CIDR)</td>
                        <td>N/A</td>
                        <td>Indicates remote IP prefix to be associated with this metering
                            rule.</td>
                    </tr>
                </tbody>
            </table>
        </section>
        <?hard-pagebreak?>
        <section xml:id="metering_operations">
            <title>Basic L3 metering operations</title>
            <para>Only administrators can manage the L3 metering labels and rules.</para>
            <para>This table shows example <command>neutron</command> commands that enable you to
                complete basic L3 metering operations:</para>
            <table rules="all">
                <caption>Basic L3 operations</caption>
                <col width="40%"/>
                <col width="60%"/>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Command</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <para>Creates a metering label.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron meter-label-create <replaceable>label1</replaceable> --description <replaceable>"description of label1"</replaceable></userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Lists metering labels.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron meter-label-list</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Shows information for a specified label.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron meter-label-show <replaceable>label-uuid</replaceable></userinput>
<prompt>$</prompt> <userinput>neutron meter-label-show <replaceable>label1</replaceable></userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Deletes a metering label.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron meter-label-delete <replaceable>label-uuid</replaceable></userinput>
<prompt>$</prompt> <userinput>neutron meter-label-delete <replaceable>label1</replaceable></userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Creates a metering rule.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron meter-label-rule-create <replaceable>label-uuid</replaceable> <replaceable>cidr</replaceable> --direction <replaceable>direction</replaceable> --excluded</userinput>
<prompt>$</prompt> <userinput>neutron meter-label-rule-create <replaceable>label1</replaceable> <replaceable>10.0.0.0/24</replaceable> --direction <replaceable>ingress</replaceable></userinput>
<prompt>$</prompt> <userinput>neutron meter-label-rule-create <replaceable>label1</replaceable> <replaceable>20.0.0.0/24</replaceable> --excluded</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Lists metering all label rules.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron meter-label-rule-list</userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <para>Shows information for a specified label rule.</para>
                        </td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron meter-label-rule-show <replaceable>rule-uuid</replaceable></userinput></screen>
                        </td>
                    </tr>
                    <tr>
                        <td>Deletes a metering label rule.</td>
                        <td>
                            <screen><prompt>$</prompt> <userinput>neutron meter-label-rule-delete <replaceable>rule-uuid</replaceable></userinput></screen>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>
</section>
<!---->
